{"version":3,"sources":["library.js"],"names":["mapMap","map","callback","newMapStart","count","entries","entry","push","Map","reduceMap","initial","current","handleCollisions","key","oldValue","newValue","numCollisions","mergeMaps","maps","finalMap","collisionRef","addMapToFinal","has","get","set","invertMap","mapFromObject","object","newMap","hasOwnProperty"],"mappings":"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","file":"library.js","sourcesContent":["/**\r\n * returns new map where callback ahs been applied to all entries\r\n */\r\nfunction mapMap(map,callback){\r\n    let newMapStart = [];\r\n    let count = 0;\r\n\r\n    for(let entry of map.entries()){\r\n        newMapStart.push(callback(...entry,count));\r\n\r\n        count++;\r\n    }\r\n\r\n    return new Map(newMapStart);\r\n}\r\n\r\n/**\r\n * returns a value after callback has been applied to all entries based on an intial value\r\n */\r\nfunction reduceMap(map,callback,initial){\r\n    let current = initial;\r\n    let count = 0;\r\n\r\n    for(let entry of map.entries()){\r\n        current = callback(current,...entry,count);\r\n\r\n        count++;\r\n    }\r\n\r\n    return current;\r\n}\r\n\r\n\r\n/**\r\n * default callback for handling key collisions during map operations\r\n */\r\nfunction handleCollisions(key, oldValue, newValue, numCollisions){\r\n    if(numCollisions > 1){\r\n        oldValue.push(newValue);\r\n        return oldValue\r\n    }\r\n    else{\r\n        return [oldValue, newValue]\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * merges an array of maps, aggregating keys that cause collisions into an array\r\n * also accepts a custom callback to handle collisions\r\n */\r\nfunction mergeMaps(maps, callback){\r\n    let finalMap = new Map();\r\n\r\n    // we need to keep track of collisions separately\r\n    let collisionRef = new Map();\r\n\r\n    // if there is no callback use the default behaviour\r\n    if(typeof callback !== 'function'){\r\n        callback = handleCollisions;\r\n    }\r\n\r\n    function addMapToFinal(map){\r\n        for (let entry of map.entries()){\r\n\r\n            if(finalMap.has(entry[0])){\r\n                let newValue = callback(entry[0], finalMap.get(entry[0]), entry[1], collisionRef.get(entry[0]));\r\n\r\n                finalMap.set(entry[0], newValue);\r\n                collisionRef.set(entry[0], collisionRef.get(entry[0]) + 1);\r\n            }\r\n            else{\r\n                finalMap.set(entry[0], entry[1]);\r\n                collisionRef.set(entry[0], 1);\r\n            }\r\n        }\r\n    }\r\n    for (let map of maps){\r\n        addMapToFinal(map);\r\n    }\r\n\r\n    return finalMap\r\n}\r\n\r\n/**\r\n * inverts the keys and values in a map, aggregating keys that cause collisions into an array\r\n */\r\nfunction invertMap(map, callback){\r\n    let finalMap = new Map();\r\n\r\n    // we need to keep track of collisions separately\r\n    let collisionRef = new Map();\r\n\r\n    // if there is no callback use the default behaviour\r\n    if(typeof callback !== 'function'){\r\n        callback = handleCollisions;\r\n    }\r\n\r\n    for (let entry of map.entries()){\r\n\r\n        if(finalMap.has(entry[1])){\r\n            let newValue = callback(entry[1], finalMap.get(entry[1]), entry[0], collisionRef.get(entry[1]));\r\n\r\n            finalMap.set(entry[1], newValue);\r\n            collisionRef.set(entry[1], collisionRef.get(entry[1]) + 1);\r\n        }\r\n        else{\r\n            finalMap.set(entry[1], entry[0]);\r\n            collisionRef.set(entry[1], 1);\r\n        }\r\n    }\r\n\r\n    return finalMap\r\n}\r\n\r\n/**\r\n * create a map from an object. Using only own properties\r\n * note that this is only a shallow conversion. any child obectes will nto be converted to a map.\r\n */\r\nfunction mapFromObject(object){\r\n    let newMap = [];\r\n\r\n    for(let key in object){\r\n        if(object.hasOwnProperty(key)){\r\n            newMap.push([key, object[key]]);\r\n        }\r\n    }\r\n\r\n    return new Map(newMap);\r\n}\r\n\r\n\r\n\r\nexport { mapMap, reduceMap, mergeMaps, invertMap, mapFromObject };\r\n"]}